<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="de-ch" http-equiv="Content-Language" />
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>design ideas</title>
<style type="text/css">
.auto-style1 {
	font-size: x-large;
	text-decoration: underline;
}
.auto-style3 {
	margin-top: 34px;
}
</style>
</head>

<body style="background-color: #ECFFD9">



<div id="layer1" style="position: absolute; width: 618px; height: 982px; z-index: 1; left: 11px; top: 71px">
	<span class="auto-style1"><strong>design ideas / diary</strong></span><br />
	<br />
	<br />
	<a href="ideas.pdf" target="_blank" >a scratch diagram of the memory 
	interfaces</a><br />
	<br />
	This scratch diagram shows a "memory interface" to the fpga. 
	Each triacdriver has got it's own address and the triac trigger delay can be 
	entered as a ten bit positive integer in the range of&nbsp; 0 to 1024. A half 
	cycle of AC (10 mSecs in our 220 V public current) is divided by 1024 and 
	the integer describes the point of time in this interval when triac trigger 
	takes place. <br />
	<br />
	The zeropass detector is needed because the triacdriver needs to be synchronised 
	with the AC timing.<br />
	<br />
	The fpga finally transmits the different trigger current pulses to the triac drivers 
	with a trigger duration of approx 5 uSecs. To be able to switch highly 
	inductive loads, a pulse train will be sent after the initial pulse with an 
	interval time of approx. 100 uSecs, what means approx 10 pulses per mSec.<br />
	<br />
	<a href="diagrams/InputComponents.jpg" target="_blank">ideas about the input/output component 
	of the rustLight project, printed out by using Quartus-II netlist RTL Viewer</a> <br />
	(built with sourcecode of&nbsp; July&nbsp; 5,&nbsp; 2016)<br />
	<br />
	<a href="diagrams/RationalRose_triacDriver.pdf">a RationalRose state diagram 
	of the triacDriver as a first idea how this driver could work</a><br />
	( March 24, 2016)<br />
	<br />
	During summertime 2016 I was rather busy with other works, holidays and 
	meetings, so that until end august I had hardly any time to work on rhe 
	rustlight project. <br />
	<br />
	Now as per September 2016 rustlight project is ready for first tests (and 
	final implementation) on the hardware and during the last days I developed 
	an interface to the cyclone III testboard from an avr32 processor bord using 
	micrium II os. I could easily develop this out of the dcfAnywhere project 
	code. This interface is ready for testing an I am developing finally a 
	little C++ application on pc to send data to the avr32 interface, which will 
	forward the data on the data/address/control wires to the cyclone III board. 
	Later I plan to develop the whole vhdl data exchange using avalon 
	communication and interfacing the application on the cyclone III board&nbsp;&nbsp; 
	via tcp/ip or serial rs232.&nbsp;&nbsp;&nbsp;&nbsp;
	<div id="layerx" class="auto-style3" style="height: 323px">&nbsp;<img height="337" src="rustlight8.jpg" width="495" /></div>



</body>

</html>
